#!/bin/bash

# usttrace  by Pierre-Marc Fournier 2009
# Distributed under the GPLv2.

USTTRACE_DIR="$(dirname $0)"
USTD="${USTTRACE_DIR}/ustd/ustd"
LIBINTERFORK_PATH="${USTTRACE_DIR}/libinterfork/.libs/libinterfork.so"
LIBMALLOCWRAP_PATH="${USTTRACE_DIR}/libmallocwrap/.libs/libmallocwrap.so"

STD_LDLIBRARY_UST="${USTTRACE_DIR}/libust/.libs"

BASE_TRACE_DIR="${HOME}/.usttraces"

function usage () {
	echo "usage:  $0 OPTIONS COMMAND" 2>/dev/stderr
	echo "" 2>/dev/stderr
	echo "Options:" 2>/dev/stderr
	echo "    -l    Runtime link with UST library." 2>/dev/stderr
	echo "          (Needed only if program was not linked at compile time with libust.)" 2>/dev/stderr
	echo "    -L    Add path to ust libraries to LD_LIBRARY_PATH." 2>/dev/stderr
	echo "    -m    Instrument malloc calls." 2>/dev/stderr
	echo "    -f    Also trace forked processes." 2>/dev/stderr
	echo "    -s    Use system-wide daemon instead of creating one for this session." 2>/dev/stderr
}

function error() {
	echo "$0: error: $1" 2>/dev/stderr
}

while getopts ":hlLmfs" options; do
	case $options in
		l) arg_preload_libust=1;;
		L) arg_ld_std_ust=1;;
		m) arg_preload_malloc=1;;
		f) arg_preload_fork=1;;
		s) arg_syswide_daemon=1;;
		h) usage;
		   exit 0;;
		\?) usage
			exit 1;;
		*) usage
			exit 1;;
	esac
done
shift $(($OPTIND - 1))

if [ ! -x "$USTD" ];
then
	error "specified path to ustd not executable ($USTD)"
	exit 1
fi

# Prepare vars
CMD=$1

# Validate input
if [ -z "$HOME" ];
then
	error "no home specified"
fi

if [ -z "$CMD" ];
then
	error "no command specified"
	usage;
	exit 1
fi

# Create directory for trace output
DATESTRING="$(hostname)-$(date +%Y%m%d%H%M%S)"
OUTDIR="$BASE_TRACE_DIR/$DATESTRING"
mkdir -p "$OUTDIR"

# Choose socket path
SOCKPATH="/tmp/ust-sock-$$"

if [ "$arg_syswide_daemon" != "1" ];
then
	pidfilepath="/tmp/usttrace-$USER-$(date +%Y%m%d%H%M%S%N)-ustd-pid"

	# Start daemon
	$USTD -d --pidfile "$pidfilepath" -s "$SOCKPATH" -o "$OUTDIR" >"$OUTDIR/ustd.log" 2>&1 &
	USTDPID="$(<$pidfilepath)"
	export UST_DAEMON_SOCKET="$SOCKPATH"
fi

# Establish the environment for the command
export UST_TRACE=1
export UST_AUTOPROBE=1

if [ "$arg_preload_libust" = "1" ];
then
	export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:./libust/.libs"
	export LD_PRELOAD="$LD_PRELOAD:./libust/.libs/libust.so"
fi

if [ "$arg_ld_std_ust" = "1" ];
then
	export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$STD_LDLIBRARY_UST"
fi

if [ "$arg_preload_malloc" = "1" ];
then
	export LD_PRELOAD="$LD_PRELOAD:./libmallocwrap/.libs/libmallocwrap.so"
fi

if [ "$arg_preload_fork" = "1" ];
then
	export LD_PRELOAD="$LD_PRELOAD:$LIBINTERFORK_PATH"
fi

# Install a handler for SIGIO. This is the signal that will be sent by ustd to
# the traced program to trigger the creation of its listener thread. However,
# it is possible that the SIGIO will be sent after the shell fork, but before
# the exec of the command. If this handler isn't there, bash might terminate
# because of a unhandled signal.

# Execute the command
bash -c "$CMD" 2>&1 | tee "$OUTDIR/app.log"

## Because of the keepalive mechanism, we're sure that by the time
## we get here, the daemon is connected to all the buffers that still exist.
## Therefore we can politely ask it to die when it's done.

if [ "$arg_syswide_daemon" != "1" ];
then
	# Tell the daemon to die
	kill -SIGTERM "$USTDPID"

	echo "Waiting for ustd to shutdown..."
	wait "$USTDPID"

	rm "$pidfilepath"
fi

echo "Trace was output in: " $OUTDIR
